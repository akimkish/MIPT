## Итоговое задание 
# Вариант 3. Нечёткий поиск, выявление дублирующихся значений
Крупный маркетплейс столкнулся с проблемой дублирования товарных предложений. Разные продавцы добавляют один и тот же товар, но в его описании могут быть опечатки, различные сокращения, синонимы, изменённый порядок слов или дополнительные характеристики. Это ухудшает пользовательский опыт и мешает системе корректно ранжировать предложения. Необходимо разработать алгоритм, который для каждого нового товара будет находить в каталоге потенциальные дубликаты.

# Краткое описание проекта
Проект разработан для решения частного случая задания - для данных из файлов catalog.txt и new_items.txt.
Создан словарь synonyms, который содержит синонимы и второстепенные слова, указание в наименование которых не играет важной роли. Эти слова необходимые для преведения наименований к мксимально возможной единой форме.
В проекте для решения задачи используются функции:
- levenshtein_distance - Метод расстояния редактирования Левенштейна для выявления дублирующих значений. Расстояние Левенштейна измеряет минимальное количество операций редактирования(вставка, удаление, замена), необходимых для преобразования одной строки в другую. Ключевая идея: использовать динамическое программирование для построения матрицы, где каждая ячейка dp[i][j] хранит минимальную стоимость преобразования префикса первой строки длиной i в префикс второй строки длиной j.
- similarity - Вычисляет схожесть на основе расстояния редактирования Левенштейна (1 - расстояние редактирования Левенштейна / максимальная длина наименования товара).
- preprocesssing - Для нормализация текста: преобразование всех символов в нижний регистр, замена синонимов, удаление второстепенных слов, удаление лишних пробелов.
Алгоритм:
1) Читаем файл new_items.txt с помощью контекстного менеджера. Нормализуем текст информации о товарах в перечне новых товарных предложений. Добавляем в список new_items.
2) Читаем файл catalog.txt с помощью контекстного менеджера. Нормализуем текст информации о товаре в каталоге товаров. Находим дубликаты новых товарных предложений с товарами из каталога с помощью вышеуказанных функций. Добавляем в список duplicates в соответствии с требованиями описания выходных данных.
3) Создаем словарь result с итоговыми результатами.
4) Сериализуем и записываем словарь Python в JSON файл - duplicates.json, где для каждого нового товара приведён список найденных дубликатов из каталога с указанием коэффициента схожести.